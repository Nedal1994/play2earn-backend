// Required libraries
const fs = require('fs');
const path = require('path');
const papa = require('papaparse');
const StandardScaler = require('ml-preprocessing').StandardScaler;
const KMeans = require('ml-kmeans');
const similarity = require('ml-similarity');
const metrics = require('ml-metrics');

// Load and parse CSV files
const tasksPath = 'C:/Users/Beam/Desktop/Smallcap.ai/tasks.csv';
const usersPath = 'C:/Users/Beam/Desktop/Smallcap.ai/users.csv';
const userTasksPath = 'C:/Users/Beam/Desktop/Smallcap.ai/user_tasks.csv';

const tasksCSV = fs.readFileSync(tasksPath, 'utf8');
const usersCSV = fs.readFileSync(usersPath, 'utf8');
const userTasksCSV = fs.readFileSync(userTasksPath, 'utf8');

const tasks = papa.parse(tasksCSV, { header: true }).data;
const users = papa.parse(usersCSV, { header: true }).data;
const userTasks = papa.parse(userTasksCSV, { header: true }).data;

// Convert timestamp to datetime
userTasks.forEach(task => {
  task.timestamp = new Date(task.timestamp);
});

// Merge dataframes
function mergeDataframes(userTasks, users, tasks) {
  return userTasks.map(userTask => {
    const user = users.find(u => u.user_id === userTask.user_id);
    const task = tasks.find(t => t.task_id === userTask.task_id);
    return { ...userTask, ...user, ...task };
  });
}

const mergedData = mergeDataframes(userTasks, users, tasks);

// Categorize users
function categorizeUsers(data) {
  const categorizedUsers = {};
  data.forEach(row => {
    if (!categorizedUsers[row.user_id]) {
      categorizedUsers[row.user_id] = {
        user_id: row.user_id,
        age: parseFloat(row.age),
        country: row.country,
        tasks_viewed: 0,
        tasks_completed: 0,
        tasks_completed_easy: 0,
        tasks_completed_medium: 0,
        tasks_completed_hard: 0,
        average_rating: 0,
        avg_time_per_task: 0,
        completion_times: []
      };
    }

    const user = categorizedUsers[row.user_id];
    if (row.interaction_type === 'viewed') {
      user.tasks_viewed++;
    } else if (row.interaction_type === 'completed') {
      user.tasks_completed++;
      if (row.difficulty === 'Easy') {
        user.tasks_completed_easy++;
      } else if (row.difficulty === 'Medium') {
        user.tasks_completed_medium++;
      } else if (row.difficulty === 'Hard') {
        user.tasks_completed_hard++;
      }
      user.average_rating += parseFloat(row.rating);
      user.completion_times.push(row.timestamp);
    }
  });

  return Object.values(categorizedUsers).map(user => {
    if (user.tasks_completed > 0) {
      user.average_rating /= user.tasks_completed;
      const timeDiffs = user.completion_times
        .sort((a, b) => a - b)
        .map((time, i, arr) => (i > 0 ? (time - arr[i - 1]) / 1000 : 0))
        .filter(diff => diff > 0);
      user.avg_time_per_task = timeDiffs.length ? timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length : 0;
    }
    return user;
  });
}

const categorizedUsers = categorizeUsers(mergedData);

// Standardize features for clustering
const features = ['age', 'tasks_viewed', 'tasks_completed', 'tasks_completed_easy', 'tasks_completed_medium', 'tasks_completed_hard', 'average_rating', 'avg_time_per_task'];
const scaler = new StandardScaler();
const scaledFeatures = scaler.fitTransform(categorizedUsers.map(user => features.map(f => user[f])));

// Clustering users
const kmeans = new KMeans({ k: 5 });
const clusters = kmeans.fit(scaledFeatures).predict(scaledFeatures);

categorizedUsers.forEach((user, i) => {
  user.cluster = clusters[i];
});

console.log(categorizedUsers.slice(0, 5));

// Create a pivot table of users and tasks with ratings as values
function createPivotTable(userTasks) {
  const pivotTable = {};
  userTasks.forEach(row => {
    if (!pivotTable[row.user_id]) pivotTable[row.user_id] = {};
    pivotTable[row.user_id][row.task_id] = parseFloat(row.rating);
  });

  return pivotTable;
}

const userTaskMatrix = createPivotTable(userTasks);

// Calculate cosine similarity
function cosineSim(matrix) {
  const users = Object.keys(matrix);
  const tasks = [...new Set(Object.values(matrix).flatMap(user => Object.keys(user)))];

  const userVectors = users.map(user => tasks.map(task => matrix[user][task] || 0));
  const taskVectors = tasks.map(task => users.map(user => matrix[user][task] || 0));

  const userSimilarity = similarity.cosine(userVectors);
  const taskSimilarity = similarity.cosine(taskVectors);

  return { userSimilarity, taskSimilarity };
}

const { userSimilarity, taskSimilarity } = cosineSim(userTaskMatrix);

// Hybrid recommendation algorithm
function hybridRecommendTasks(userId, nRecommendations = 5, alpha = 0.5) {
  const userIndex = Object.keys(userTaskMatrix).indexOf(userId.toString());
  const similarUsers = userSimilarity[userIndex];
  const userRatings = userTaskMatrix[userId] || {};

  const taskSimScores = taskSimilarity.map((scores, i) => ({
    task: i,
    score: Object.keys(userRatings).reduce((sum, task) => sum + (userRatings[task] * scores[task]), 0) / scores.reduce((sum, score) => sum + score, 0)
  }));

  const hybridScores = taskSimScores.map((task, i) => ({
    task: i,
    score: alpha * task.score + (1 - alpha) * similarUsers.reduce((sum, user, j) => sum + (userTaskMatrix[user][i] || 0) * user, 0)
  }));

  return hybridScores
    .sort((a, b) => b.score - a.score)
    .slice(0, nRecommendations)
    .map(rec => rec.task);
}

// Example usage: Recommend tasks for specific users
[1, 2, 3, 4, 5].forEach(userId => {
  const recommendedTasks = hybridRecommendTasks(userId);
  console.log(`Recommended tasks for user ${userId}: ${recommendedTasks}`);
});

// Evaluate the recommendation system
function evaluateRecommendations() {
  const yTrue = [];
  const yPred = [];

  Object.keys(userTaskMatrix).forEach(userId => {
    const actualTasks = Object.keys(userTaskMatrix[userId]).filter(task => userTaskMatrix[userId][task] > 0);
    const recommendedTasks = hybridRecommendTasks(userId, actualTasks.length);

    yTrue.push(...actualTasks.map(() => 1), ...Object.keys(userTaskMatrix[0]).filter(task => !actualTasks.includes(task)).map(() => 0));
    yPred.push(...Object.keys(userTaskMatrix[0]).map(task => (recommendedTasks.includes(task) ? 1 : 0)));
  });

  const precision = metrics.precision(yTrue, yPred);
  const recall = metrics.recall(yTrue, yPred);
  const f1 = metrics.f1(yTrue, yPred);
  const mae = metrics.meanAbsoluteError(yTrue, yPred);

  console.log(`Precision: ${precision.toFixed(4)}, Recall: ${recall.toFixed(4)}, F1 Score: ${f1.toFixed(4)}, MAE: ${mae.toFixed(4)}`);
}

evaluateRecommendations();
