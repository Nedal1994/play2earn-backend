const fs = require('fs');
const path = require('path');
const papa = require('papaparse');
const KMeans = require('ml-kmeans');
const { cosine } = require('ml-distance');
const { Matrix, MatrixTransposeView } = require('ml-matrix');
const { precision, recall, f1, meanAbsoluteError } = require('ml-metrics');

// Load and parse CSV files
const loadCSV = (filePath) => {
    const csvData = fs.readFileSync(filePath, 'utf8');
    return papa.parse(csvData, { header: true, dynamicTyping: true }).data;
};

const tasks = loadCSV('C:/Users/Beam/Desktop/Smallcap.ai/tasks.csv');
const users = loadCSV('C:/Users/Beam/Desktop/Smallcap.ai/users.csv');
const userTasks = loadCSV('C:/Users/Beam/Desktop/Smallcap.ai/user_tasks.csv');

// Convert timestamp to datetime
userTasks.forEach(task => {
    task.timestamp = new Date(task.timestamp);
});

// Merge dataframes
const mergeDataframes = (userTasks, users, tasks) => {
    return userTasks.map(userTask => {
        const user = users.find(u => u.user_id === userTask.user_id);
        const task = tasks.find(t => t.task_id === userTask.task_id);
        return { ...userTask, ...user, ...task };
    });
};

const mergedData = mergeDataframes(userTasks, users, tasks);

// Categorize users
const categorizeUsers = (data) => {
    const categorizedUsers = {};

    data.forEach(row => {
        if (!categorizedUsers[row.user_id]) {
            categorizedUsers[row.user_id] = {
                user_id: row.user_id,
                age: row.age,
                country: row.country,
                tasks_viewed: 0,
                tasks_completed: 0,
                tasks_completed_easy: 0,
                tasks_completed_medium: 0,
                tasks_completed_hard: 0,
                average_rating: 0,
                avg_time_per_task: 0,
                completion_times: []
            };
        }

        const user = categorizedUsers[row.user_id];
        if (row.interaction_type === 'viewed') {
            user.tasks_viewed++;
        } else if (row.interaction_type === 'completed') {
            user.tasks_completed++;
            if (row.difficulty === 'Easy') {
                user.tasks_completed_easy++;
            } else if (row.difficulty === 'Medium') {
                user.tasks_completed_medium++;
            } else if (row.difficulty === 'Hard') {
                user.tasks_completed_hard++;
            }
            user.average_rating += row.rating;
            user.completion_times.push(row.timestamp);
        }
    });

    return Object.values(categorizedUsers).map(user => {
        if (user.tasks_completed > 0) {
            user.average_rating /= user.tasks_completed;
            const timeDiffs = user.completion_times
                .sort((a, b) => a - b)
                .map((time, i, arr) => (i > 0 ? (time - arr[i - 1]) / 1000 : 0))
                .filter(diff => diff > 0);
            user.avg_time_per_task = timeDiffs.length ? timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length : 0;
        }
        return user;
    });
};

const categorizedUsers = categorizeUsers(mergedData);

// Standardize features for clustering
const standardize = (data) => {
    const mean = data.reduce((acc, val) => acc.map((a, i) => a + val[i]), Array(data[0].length).fill(0)).map(a => a / data.length);
    const std = data.reduce((acc, val) => acc.map((a, i) => a + Math.pow(val[i] - mean[i], 2)), Array(data[0].length).fill(0)).map(a => Math.sqrt(a / data.length));
    return data.map(row => row.map((val, i) => (val - mean[i]) / std[i]));
};

const features = categorizedUsers.map(user => [
    user.age, user.tasks_viewed, user.tasks_completed, user.tasks_completed_easy, user.tasks_completed_medium, user.tasks_completed_hard, user.average_rating, user.avg_time_per_task
]);

const standardizedFeatures = standardize(features);

// Clustering users
const kmeans = new KMeans();
const clusters = kmeans.cluster(standardizedFeatures, 5);

categorizedUsers.forEach((user, i) => {
    user.cluster = clusters[i];
});

console.log(categorizedUsers.slice(0, 5));

// Create a pivot table of users and tasks with ratings as values
const createPivotTable = (userTasks) => {
    const pivotTable = {};
    userTasks.forEach(row => {
        if (!pivotTable[row.user_id]) pivotTable[row.user_id] = {};
        pivotTable[row.user_id][row.task_id] = row.rating;
    });
    return pivotTable;
};

const userTaskMatrix = createPivotTable(userTasks);

// Calculate cosine similarity
const calculateSimilarity = (matrix) => {
    const userKeys = Object.keys(matrix);
    const taskKeys = Array.from(new Set(Object.values(matrix).flatMap(user => Object.keys(user))));

    const userVectors = userKeys.map(user => taskKeys.map(task => matrix[user][task] || 0));
    const taskVectors = taskKeys.map(task => userKeys.map(user => matrix[user][task] || 0));

    const userSimilarity = cosine(userVectors);
    const taskSimilarity = cosine(taskVectors);

    return { userSimilarity, taskSimilarity };
};

const { userSimilarity, taskSimilarity } = calculateSimilarity(userTaskMatrix);

// Hybrid recommendation algorithm
const hybridRecommendTasks = (userId, nRecommendations = 5, alpha = 0.5) => {
    const userIndex = Object.keys(userTaskMatrix).indexOf(userId.toString());
    const similarUsers = userSimilarity[userIndex];
    const userRatings = userTaskMatrix[userId] || {};

    const taskSimScores = taskSimilarity.map((scores, i) => ({
        task: i,
        score: Object.keys(userRatings).reduce((sum, task) => sum + (userRatings[task] * scores[task]), 0) / scores.reduce((sum, score) => sum + score, 0)
    }));

    const hybridScores = taskSimScores.map((task, i) => ({
        task: i,
        score: alpha * task.score + (1 - alpha) * similarUsers.reduce((sum, user, j) => sum + (userTaskMatrix[user][i] || 0) * user, 0)
    }));

    return hybridScores
        .sort((a, b) => b.score - a.score)
        .slice(0, nRecommendations)
        .map(rec => rec.task);
};

// Example usage: Recommend tasks for specific users
[1, 2, 3, 4, 5].forEach(userId => {
    const recommendedTasks = hybridRecommendTasks(userId);
    console.log(`Recommended tasks for user ${userId}: ${recommendedTasks}`);
});

// Evaluate the recommendation system
const evaluateRecommendations = () => {
    const yTrue = [];
    const yPred = [];

    Object.keys(userTaskMatrix).forEach(userId => {
        const actualTasks = Object.keys(userTaskMatrix[userId]).filter(task => userTaskMatrix[userId][task] > 0);
        const recommendedTasks = hybridRecommendTasks(userId, actualTasks.length);

        yTrue.push(...actualTasks.map(() => 1), ...Object.keys(userTaskMatrix[0]).filter(task => !actualTasks.includes(task)).map(() => 0));
        yPred.push(...Object.keys(userTaskMatrix[0]).map(task => (recommendedTasks.includes(task) ? 1 : 0)));
    });

    const precisionScore = precision(yTrue, yPred);
    const recallScore = recall(yTrue, yPred);
    const f1Score = f1(yTrue, yPred);
    const maeScore = meanAbsoluteError(yTrue, yPred);

    console.log(`Precision: ${precisionScore.toFixed(4)}, Recall: ${recallScore.toFixed(4)}, F1 Score: ${f1Score.toFixed(4)}, MAE: ${maeScore.toFixed(4)}`);
};

evaluateRecommendations();
